"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const updateRelatedChangeType_1 = require("../../bump/updateRelatedChangeType");
const lodash_1 = __importDefault(require("lodash"));
describe('updateRelatedChangeType', () => {
    const bumpInfoFixture = {
        changes: new Map(),
        dependents: {},
        packageChangeTypes: {},
        dependentChangeTypes: {
            foo: 'patch',
        },
        packageInfos: {
            foo: {
                name: 'foo',
                combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
            },
            bar: {
                name: 'bar',
                combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
            },
            baz: {
                name: 'baz',
                combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
            },
        },
        modifiedPackages: new Set(),
        newPackages: new Set(),
        packageGroups: {},
        groupOptions: {},
    };
    const changeInfoFixture = {
        dependentChangeType: 'none',
        packageName: 'foo',
        comment: 'test comment',
        commit: '0xdeadbeef',
        email: 'test@dev.com',
        type: 'none',
    };
    it('should bump dependent packages with "patch" change type by default', () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
            },
            packageChangeTypes: {
                foo: {
                    type: 'minor',
                },
            },
            packageInfos: {
                bar: {
                    dependencies: {
                        foo: '1.0.0',
                    },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'minor' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('patch');
        expect(dependentChangeInfos.size).toBe(1);
        const fooChangeInfos = dependentChangeInfos.get('foo');
        expect(fooChangeInfos).toBeDefined();
        expect((_a = fooChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const fooChangeInfo = (_b = fooChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = fooChangeInfo) === null || _c === void 0 ? void 0 : _c.type).toBe('patch');
        expect((_d = fooChangeInfo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = fooChangeInfo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = fooChangeInfo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = fooChangeInfo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
    });
    it('should bump dependent packages according to the bumpInfo.dependentChangeTypes', () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
            },
            packageChangeTypes: {
                foo: { type: 'patch' },
            },
            dependentChangeTypes: {
                foo: 'minor',
            },
            packageInfos: {
                bar: {
                    dependencies: {
                        foo: '1.0.0',
                    },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(dependentChangeInfos.size).toBe(1);
        const fooDependentChangeInfos = dependentChangeInfos.get('foo');
        expect(fooDependentChangeInfos).toBeDefined();
        expect((_a = fooDependentChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const barDependentChangeInfo = (_b = fooDependentChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = barDependentChangeInfo) === null || _c === void 0 ? void 0 : _c.type).toBe('minor');
        expect((_d = barDependentChangeInfo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = barDependentChangeInfo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = barDependentChangeInfo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = barDependentChangeInfo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
    });
    it("should bump dependent packages according to the bumpInfo.dependentChangeTypes and respect package's own change type", () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
                bar: ['app'],
            },
            packageChangeTypes: {
                foo: { type: 'patch' },
                bar: { type: 'major' },
            },
            dependentChangeTypes: {
                foo: 'patch',
                bar: 'minor',
            },
            packageInfos: {
                app: {
                    dependencies: {
                        bar: '1.0.0',
                    },
                },
                bar: {
                    dependencies: {
                        foo: '1.0.0',
                    },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        updateRelatedChangeType_1.updateRelatedChangeType('bar', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('major');
        expect(bumpInfo.packageChangeTypes['app'].type).toBe('patch');
        expect(dependentChangeInfos.size).toBe(2);
        const fooDependentChangeInfos = dependentChangeInfos.get('foo');
        expect((_a = fooDependentChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const barChangeInfoForFoo = (_b = fooDependentChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = barChangeInfoForFoo) === null || _c === void 0 ? void 0 : _c.type).toBe('patch');
        expect((_d = barChangeInfoForFoo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = barChangeInfoForFoo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = barChangeInfoForFoo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = barChangeInfoForFoo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
        const barDependentChangeInfos = dependentChangeInfos.get('bar');
        expect((_h = barDependentChangeInfos) === null || _h === void 0 ? void 0 : _h.size).toBe(1);
        const appChangeInfoForBar = (_j = barDependentChangeInfos) === null || _j === void 0 ? void 0 : _j.get('app');
        expect((_k = appChangeInfoForBar) === null || _k === void 0 ? void 0 : _k.type).toBe('patch');
        expect((_l = appChangeInfoForBar) === null || _l === void 0 ? void 0 : _l.packageName).toBe('app');
        expect((_m = appChangeInfoForBar) === null || _m === void 0 ? void 0 : _m.commit).toBe('0xdeadbeef');
        expect((_o = appChangeInfoForBar) === null || _o === void 0 ? void 0 : _o.email).toBe('test@dev.com');
        expect((_p = appChangeInfoForBar) === null || _p === void 0 ? void 0 : _p.comment).toBe('');
    });
    it('should bump dependent packages according to the bumpInfo.dependentChangeTypes and dependentChangeInfos must stay up to date', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
                baz: ['bar'],
                bar: ['app'],
            },
            packageChangeTypes: {
                foo: { type: 'patch' },
                baz: { type: 'minor' },
            },
            dependentChangeTypes: {
                foo: 'patch',
                baz: 'minor',
            },
            packageInfos: {
                app: {
                    dependencies: {
                        bar: '1.0.0',
                    },
                },
                bar: {
                    dependencies: {
                        foo: '1.0.0',
                        baz: '2.0.0',
                    },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['baz'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['app'].type).toBe('patch');
        expect(dependentChangeInfos.size).toBe(2);
        const fooDependentChangeInfos = dependentChangeInfos.get('foo');
        expect((_a = fooDependentChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const barChangeInfoForFoo = (_b = fooDependentChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = barChangeInfoForFoo) === null || _c === void 0 ? void 0 : _c.type).toBe('patch');
        expect((_d = barChangeInfoForFoo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = barChangeInfoForFoo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = barChangeInfoForFoo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = barChangeInfoForFoo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
        const barDependentChangeInfos = dependentChangeInfos.get('bar');
        expect((_h = barDependentChangeInfos) === null || _h === void 0 ? void 0 : _h.size).toBe(1);
        const appChangeInfoForBar = (_j = barDependentChangeInfos) === null || _j === void 0 ? void 0 : _j.get('app');
        expect((_k = appChangeInfoForBar) === null || _k === void 0 ? void 0 : _k.type).toBe('patch');
        expect((_l = appChangeInfoForBar) === null || _l === void 0 ? void 0 : _l.packageName).toBe('app');
        expect((_m = appChangeInfoForBar) === null || _m === void 0 ? void 0 : _m.commit).toBe('0xdeadbeef');
        expect((_o = appChangeInfoForBar) === null || _o === void 0 ? void 0 : _o.email).toBe('test@dev.com');
        expect((_p = appChangeInfoForBar) === null || _p === void 0 ? void 0 : _p.comment).toBe('');
        updateRelatedChangeType_1.updateRelatedChangeType('baz', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch', email: 'dev@test.com', commit: '0xfeef' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['baz'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['app'].type).toBe('minor');
        expect(dependentChangeInfos.size).toBe(3);
        const fooDependentChangeInfos2 = dependentChangeInfos.get('foo');
        expect((_q = fooDependentChangeInfos2) === null || _q === void 0 ? void 0 : _q.size).toBe(1);
        const barChangeInfoForFoo2 = (_r = fooDependentChangeInfos) === null || _r === void 0 ? void 0 : _r.get('bar');
        expect((_s = barChangeInfoForFoo2) === null || _s === void 0 ? void 0 : _s.type).toBe('patch');
        expect((_t = barChangeInfoForFoo2) === null || _t === void 0 ? void 0 : _t.packageName).toBe('bar');
        expect((_u = barChangeInfoForFoo2) === null || _u === void 0 ? void 0 : _u.commit).toBe('0xdeadbeef');
        expect((_v = barChangeInfoForFoo2) === null || _v === void 0 ? void 0 : _v.email).toBe('test@dev.com');
        expect((_w = barChangeInfoForFoo2) === null || _w === void 0 ? void 0 : _w.comment).toBe('');
        const bazDependentChangeInfos = dependentChangeInfos.get('baz');
        expect((_x = bazDependentChangeInfos) === null || _x === void 0 ? void 0 : _x.size).toBe(1);
        const bazChangeInfoForBar = (_y = bazDependentChangeInfos) === null || _y === void 0 ? void 0 : _y.get('bar');
        expect((_z = bazChangeInfoForBar) === null || _z === void 0 ? void 0 : _z.type).toBe('minor');
        expect((_0 = bazChangeInfoForBar) === null || _0 === void 0 ? void 0 : _0.packageName).toBe('bar');
        expect((_1 = bazChangeInfoForBar) === null || _1 === void 0 ? void 0 : _1.commit).toBe('0xfeef');
        expect((_2 = bazChangeInfoForBar) === null || _2 === void 0 ? void 0 : _2.email).toBe('dev@test.com');
        expect((_3 = bazChangeInfoForBar) === null || _3 === void 0 ? void 0 : _3.comment).toBe('');
        const barDependentChangeInfos2 = dependentChangeInfos.get('bar');
        expect((_4 = barDependentChangeInfos2) === null || _4 === void 0 ? void 0 : _4.size).toBe(1);
        const appChangeInfoForBar2 = (_5 = barDependentChangeInfos2) === null || _5 === void 0 ? void 0 : _5.get('app');
        expect((_6 = appChangeInfoForBar2) === null || _6 === void 0 ? void 0 : _6.type).toBe('minor');
        expect((_7 = appChangeInfoForBar2) === null || _7 === void 0 ? void 0 : _7.packageName).toBe('app');
        expect((_8 = appChangeInfoForBar2) === null || _8 === void 0 ? void 0 : _8.commit).toBe('0xfeef');
        expect((_9 = appChangeInfoForBar2) === null || _9 === void 0 ? void 0 : _9.email).toBe('dev@test.com');
        expect((_10 = appChangeInfoForBar2) === null || _10 === void 0 ? void 0 : _10.comment).toBe('');
    });
    it('should bump dependent packages according to the bumpInfo.dependentChangeTypes and roll-up multiple change infos', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
                bar: ['app'],
                baz: ['bar', 'app'],
            },
            packageChangeTypes: {
                foo: { type: 'patch' },
                baz: { type: 'patch' },
            },
            dependentChangeTypes: {
                foo: 'major',
                baz: 'minor',
            },
            packageInfos: {
                app: {
                    dependencies: {
                        bar: '1.0.0',
                        baz: '2.0.0',
                    },
                },
                bar: {
                    dependencies: {
                        foo: '1.0.0',
                        baz: '2.0.0',
                    },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        updateRelatedChangeType_1.updateRelatedChangeType('baz', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['baz'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('major');
        expect(bumpInfo.packageChangeTypes['app'].type).toBe('major');
        expect(dependentChangeInfos.size).toBe(3);
        const fooDependentChangeInfos = dependentChangeInfos.get('foo');
        expect((_a = fooDependentChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const barChangeInfoForFoo = (_b = fooDependentChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = barChangeInfoForFoo) === null || _c === void 0 ? void 0 : _c.type).toBe('major');
        expect((_d = barChangeInfoForFoo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = barChangeInfoForFoo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = barChangeInfoForFoo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = barChangeInfoForFoo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
        const barDependentChangeInfos = dependentChangeInfos.get('bar');
        expect((_h = barDependentChangeInfos) === null || _h === void 0 ? void 0 : _h.size).toBe(1);
        const appChangeInfoForBar = (_j = barDependentChangeInfos) === null || _j === void 0 ? void 0 : _j.get('app');
        expect((_k = appChangeInfoForBar) === null || _k === void 0 ? void 0 : _k.type).toBe('major');
        expect((_l = appChangeInfoForBar) === null || _l === void 0 ? void 0 : _l.packageName).toBe('app');
        expect((_m = appChangeInfoForBar) === null || _m === void 0 ? void 0 : _m.commit).toBe('0xdeadbeef');
        expect((_o = appChangeInfoForBar) === null || _o === void 0 ? void 0 : _o.email).toBe('test@dev.com');
        expect((_p = appChangeInfoForBar) === null || _p === void 0 ? void 0 : _p.comment).toBe('');
        const bazDependentChangeInfos = dependentChangeInfos.get('baz');
        expect((_q = bazDependentChangeInfos) === null || _q === void 0 ? void 0 : _q.size).toBe(2);
        const barChangeInfoForBaz = (_r = bazDependentChangeInfos) === null || _r === void 0 ? void 0 : _r.get('bar');
        expect((_s = barChangeInfoForBaz) === null || _s === void 0 ? void 0 : _s.type).toBe('minor');
        expect((_t = barChangeInfoForBaz) === null || _t === void 0 ? void 0 : _t.packageName).toBe('bar');
        expect((_u = barChangeInfoForBaz) === null || _u === void 0 ? void 0 : _u.commit).toBe('0xdeadbeef');
        expect((_v = barChangeInfoForBaz) === null || _v === void 0 ? void 0 : _v.email).toBe('test@dev.com');
        expect((_w = barChangeInfoForBaz) === null || _w === void 0 ? void 0 : _w.comment).toBe('');
        const appChangeInfoForBaz = (_x = bazDependentChangeInfos) === null || _x === void 0 ? void 0 : _x.get('app');
        expect((_y = appChangeInfoForBaz) === null || _y === void 0 ? void 0 : _y.type).toBe('minor');
        expect((_z = appChangeInfoForBaz) === null || _z === void 0 ? void 0 : _z.packageName).toBe('app');
        expect((_0 = appChangeInfoForBaz) === null || _0 === void 0 ? void 0 : _0.commit).toBe('0xdeadbeef');
        expect((_1 = appChangeInfoForBaz) === null || _1 === void 0 ? void 0 : _1.email).toBe('test@dev.com');
        expect((_2 = appChangeInfoForBaz) === null || _2 === void 0 ? void 0 : _2.comment).toBe('');
    });
    it('should bump all packages in a group together as minor', () => {
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                foo: 'minor',
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                },
                unrelated: {},
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'minor' }), bumpInfo, dependentChangeInfos, true);
        expect(dependentChangeInfos.size).toBe(0);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['unrelated']).toBeUndefined();
    });
    it('should bump all packages in a group together as patch', () => {
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                foo: 'patch',
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                },
                unrelated: {},
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(dependentChangeInfos.size).toBe(0);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['unrelated']).toBeUndefined();
    });
    it('should bump all packages in a group together as none', () => {
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                foo: 'patch',
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                },
                unrelated: {},
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'none' }), bumpInfo, dependentChangeInfos, true);
        expect(dependentChangeInfos.size).toBe(0);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('none');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('none');
        expect(bumpInfo.packageChangeTypes['unrelated']).toBeUndefined();
    });
    it('should bump all packages in a group together as none with dependents', () => {
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependents: {
                foo: ['bar'],
            },
            dependentChangeTypes: {
                foo: 'none',
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                },
                unrelated: {},
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'none' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('none');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('none');
        expect(bumpInfo.packageChangeTypes['unrelated']).toBeUndefined();
        expect(dependentChangeInfos.size).toBe(0);
    });
    it('should bump all grouped packages, if a dependency was bumped', () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                dep: 'minor',
            },
            dependents: {
                dep: ['bar'],
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                    dependencies: {
                        dep: '1.0.0',
                    },
                },
                dep: {
                    name: 'dep',
                    combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
                },
                unrelated: {
                    name: 'unrelated',
                    combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
                },
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('dep', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['dep'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['unrelated']).toBeUndefined();
        expect(dependentChangeInfos.size).toBe(1);
        const depChangeInfos = dependentChangeInfos.get('dep');
        expect(depChangeInfos).toBeDefined();
        expect((_a = depChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const depChangeInfo = (_b = depChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = depChangeInfo) === null || _c === void 0 ? void 0 : _c.type).toBe('minor');
        expect((_d = depChangeInfo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = depChangeInfo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = depChangeInfo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = depChangeInfo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
    });
    it('should bump dependent package, if a dependency was in a group', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                dep: 'minor',
            },
            dependents: {
                dep: ['bar'],
                foo: ['app'],
            },
            packageInfos: {
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                    dependencies: {
                        dep: '1.0.0',
                    },
                },
                dep: {
                    name: 'dep',
                    combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
                },
                app: {
                    name: 'app',
                    dependencies: {
                        foo: '1.0.0',
                    },
                    combinedOptions: { disallowedChangeTypes: [], defaultNpmTag: 'latest' },
                },
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('dep', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['dep'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['app'].type).toBe('minor');
        expect(dependentChangeInfos.size).toBe(2);
        const depChangeInfos = dependentChangeInfos.get('dep');
        expect(depChangeInfos).toBeDefined();
        expect((_a = depChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const depChangeInfo = (_b = depChangeInfos) === null || _b === void 0 ? void 0 : _b.get('bar');
        expect((_c = depChangeInfo) === null || _c === void 0 ? void 0 : _c.type).toBe('minor');
        expect((_d = depChangeInfo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('bar');
        expect((_e = depChangeInfo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = depChangeInfo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = depChangeInfo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
        const fooChangeInfos = dependentChangeInfos.get('foo');
        expect(fooChangeInfos).toBeDefined();
        expect((_h = fooChangeInfos) === null || _h === void 0 ? void 0 : _h.size).toBe(1);
        const fooChangeInfo = (_j = fooChangeInfos) === null || _j === void 0 ? void 0 : _j.get('app');
        expect((_k = fooChangeInfo) === null || _k === void 0 ? void 0 : _k.type).toBe('minor');
        expect((_l = fooChangeInfo) === null || _l === void 0 ? void 0 : _l.packageName).toBe('app');
        expect((_m = fooChangeInfo) === null || _m === void 0 ? void 0 : _m.commit).toBe('0xdeadbeef');
        expect((_o = fooChangeInfo) === null || _o === void 0 ? void 0 : _o.email).toBe('test@dev.com');
        expect((_p = fooChangeInfo) === null || _p === void 0 ? void 0 : _p.comment).toBe('');
    });
    it('should propagate dependent change type across group', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            dependentChangeTypes: {
                mergeStyles: 'minor',
                datetimeUtils: 'patch',
            },
            dependents: {
                mergeStyles: ['styling'],
                styling: ['bar'],
                utils: ['bar'],
                bar: ['datetime'],
                datetimeUtils: ['datetime'],
            },
            packageInfos: {
                styling: {
                    name: 'styling',
                    dependencies: {
                        mergeStyles: '1.0.0',
                    },
                },
                utils: {
                    name: 'utils',
                },
                mergeStyles: {
                    name: 'mergeStyles',
                },
                foo: {
                    group: 'grp',
                },
                bar: {
                    group: 'grp',
                    dependencies: {
                        styling: '1.0.0',
                        utils: '1.0.0',
                    },
                },
                datetime: {
                    name: 'datetime',
                    dependencies: {
                        bar: '1.0.0',
                        datetimeUtils: '1.0.0',
                    },
                },
                datetimeUtils: {
                    name: 'datetimeUtils',
                },
            },
            packageGroups: { grp: { packageNames: ['foo', 'bar'] } },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('mergeStyles', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        updateRelatedChangeType_1.updateRelatedChangeType('datetimeUtils', Object.assign(Object.assign({}, changeInfoFixture), { type: 'patch' }), bumpInfo, dependentChangeInfos, true);
        expect(dependentChangeInfos.size).toBe(4);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['bar'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['mergeStyles'].type).toBe('patch');
        expect(bumpInfo.packageChangeTypes['datetime'].type).toBe('minor');
        expect(bumpInfo.packageChangeTypes['datetimeUtils'].type).toBe('patch');
        const mergeStylesChangeInfos = dependentChangeInfos.get('mergeStyles');
        expect(mergeStylesChangeInfos).toBeDefined();
        expect((_a = mergeStylesChangeInfos) === null || _a === void 0 ? void 0 : _a.size).toBe(1);
        const mergeStyleChangeInfo = (_b = mergeStylesChangeInfos) === null || _b === void 0 ? void 0 : _b.get('styling');
        expect((_c = mergeStyleChangeInfo) === null || _c === void 0 ? void 0 : _c.type).toBe('minor');
        expect((_d = mergeStyleChangeInfo) === null || _d === void 0 ? void 0 : _d.packageName).toBe('styling');
        expect((_e = mergeStyleChangeInfo) === null || _e === void 0 ? void 0 : _e.commit).toBe('0xdeadbeef');
        expect((_f = mergeStyleChangeInfo) === null || _f === void 0 ? void 0 : _f.email).toBe('test@dev.com');
        expect((_g = mergeStyleChangeInfo) === null || _g === void 0 ? void 0 : _g.comment).toBe('');
        const stylingChangeInfos = dependentChangeInfos.get('styling');
        expect(stylingChangeInfos).toBeDefined();
        expect((_h = stylingChangeInfos) === null || _h === void 0 ? void 0 : _h.size).toBe(1);
        const stylingChangeInfo = (_j = stylingChangeInfos) === null || _j === void 0 ? void 0 : _j.get('bar');
        expect((_k = stylingChangeInfo) === null || _k === void 0 ? void 0 : _k.type).toBe('minor');
        expect((_l = stylingChangeInfo) === null || _l === void 0 ? void 0 : _l.packageName).toBe('bar');
        expect((_m = stylingChangeInfo) === null || _m === void 0 ? void 0 : _m.commit).toBe('0xdeadbeef');
        expect((_o = stylingChangeInfo) === null || _o === void 0 ? void 0 : _o.email).toBe('test@dev.com');
        expect((_p = stylingChangeInfo) === null || _p === void 0 ? void 0 : _p.comment).toBe('');
        const barChangeInfos = dependentChangeInfos.get('bar');
        expect(barChangeInfos).toBeDefined();
        expect((_q = barChangeInfos) === null || _q === void 0 ? void 0 : _q.size).toBe(1);
        const barChangeInfo = (_r = barChangeInfos) === null || _r === void 0 ? void 0 : _r.get('datetime');
        expect((_s = barChangeInfo) === null || _s === void 0 ? void 0 : _s.type).toBe('minor');
        expect((_t = barChangeInfo) === null || _t === void 0 ? void 0 : _t.packageName).toBe('datetime');
        expect((_u = barChangeInfo) === null || _u === void 0 ? void 0 : _u.commit).toBe('0xdeadbeef');
        expect((_v = barChangeInfo) === null || _v === void 0 ? void 0 : _v.email).toBe('test@dev.com');
        expect((_w = barChangeInfo) === null || _w === void 0 ? void 0 : _w.comment).toBe('');
        const datetimeUtilsChangeInfos = dependentChangeInfos.get('datetimeUtils');
        expect(datetimeUtilsChangeInfos).toBeDefined();
        expect((_x = datetimeUtilsChangeInfos) === null || _x === void 0 ? void 0 : _x.size).toBe(1);
        const datetimeUtilsChangeInfo = (_y = datetimeUtilsChangeInfos) === null || _y === void 0 ? void 0 : _y.get('datetime');
        expect((_z = datetimeUtilsChangeInfo) === null || _z === void 0 ? void 0 : _z.type).toBe('patch');
        expect((_0 = datetimeUtilsChangeInfo) === null || _0 === void 0 ? void 0 : _0.packageName).toBe('datetime');
        expect((_1 = datetimeUtilsChangeInfo) === null || _1 === void 0 ? void 0 : _1.commit).toBe('0xdeadbeef');
        expect((_2 = datetimeUtilsChangeInfo) === null || _2 === void 0 ? void 0 : _2.email).toBe('test@dev.com');
        expect((_3 = datetimeUtilsChangeInfo) === null || _3 === void 0 ? void 0 : _3.comment).toBe('');
    });
    it('should respect disallowed change type', () => {
        const bumpInfo = lodash_1.default.merge(lodash_1.default.cloneDeep(bumpInfoFixture), {
            packageInfos: {
                foo: {
                    combinedOptions: { disallowedChangeTypes: ['minor', 'major'], defaultNpmTag: 'latest' },
                },
            },
        });
        const dependentChangeInfos = new Map();
        updateRelatedChangeType_1.updateRelatedChangeType('foo', Object.assign(Object.assign({}, changeInfoFixture), { type: 'major' }), bumpInfo, dependentChangeInfos, true);
        expect(dependentChangeInfos.size).toBe(0);
        expect(bumpInfo.packageChangeTypes['foo'].type).toBe('patch');
    });
});
//# sourceMappingURL=updateRelatedChangeType.test.js.map