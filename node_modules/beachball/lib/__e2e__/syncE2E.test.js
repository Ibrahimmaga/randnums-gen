"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const tmp = __importStar(require("tmp"));
const sync_1 = require("../commands/sync");
const registry_1 = require("../fixtures/registry");
const repository_1 = require("../fixtures/repository");
const getPackageInfos_1 = require("../monorepo/getPackageInfos");
const infoFromPackageJson_1 = require("../monorepo/infoFromPackageJson");
const packagePublish_1 = require("../packageManager/packagePublish");
function createRepoPackage(repo, name, version) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = {
            name: name,
            version: version,
        };
        yield repo.commitChange(`packages/${name}/package.json`, JSON.stringify(packageJson));
    });
}
function createTempPackage(name, version, tag = 'latest') {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJsonFile = path_1.default.join(tmp.dirSync().name, 'package.json');
        const packageJson = {
            name: name,
            version: version,
            beachball: {
                tag,
            },
        };
        fs_extra_1.default.writeJSONSync(packageJsonFile, packageJson, { spaces: 2 });
        return infoFromPackageJson_1.infoFromPackageJson(packageJson, packageJsonFile);
    });
}
describe('sync command (e2e)', () => {
    const repositoryFactory = new repository_1.RepositoryFactory();
    let registry;
    beforeAll(() => {
        registry = new registry_1.Registry();
        jest.setTimeout(30000);
    });
    afterAll(() => {
        registry.stop();
    });
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield registry.reset();
        yield repositoryFactory.create();
    }));
    afterEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield repositoryFactory.cleanUp();
    }));
    it('can perform a successful sync', () => __awaiter(void 0, void 0, void 0, function* () {
        const repo = yield repositoryFactory.cloneRepository();
        yield createRepoPackage(repo, 'foopkg', '1.0.0');
        yield createRepoPackage(repo, 'barpkg', '2.2.0');
        yield createRepoPackage(repo, 'bazpkg', '3.0.0');
        const packageInfosBeforeSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        expect(packagePublish_1.packagePublish(packageInfosBeforeSync['foopkg'], registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(packageInfosBeforeSync['barpkg'], registry.getUrl(), '', '').success).toBeTruthy();
        const newFooInfo = yield createTempPackage('foopkg', '1.2.0');
        const newBarInfo = yield createTempPackage('barpkg', '3.0.0');
        expect(packagePublish_1.packagePublish(newFooInfo, registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(newBarInfo, registry.getUrl(), '', '').success).toBeTruthy();
        yield sync_1.sync({
            all: false,
            branch: 'origin/master',
            command: 'sync',
            message: '',
            path: repo.rootPath,
            publish: false,
            bumpDeps: false,
            push: false,
            registry: registry.getUrl(),
            gitTags: false,
            tag: '',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: false,
            generateChangelog: false,
            dependentChangeType: null,
        });
        const packageInfosAfterSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        expect(packageInfosAfterSync['foopkg'].version).toEqual('1.2.0');
        expect(packageInfosAfterSync['barpkg'].version).toEqual('3.0.0');
        expect(packageInfosAfterSync['bazpkg'].version).toEqual('3.0.0');
    }));
    it('can perform a successful sync using dist tag', () => __awaiter(void 0, void 0, void 0, function* () {
        const repo = yield repositoryFactory.cloneRepository();
        yield createRepoPackage(repo, 'apkg', '1.0.0');
        yield createRepoPackage(repo, 'bpkg', '2.2.0');
        yield createRepoPackage(repo, 'cpkg', '3.0.0');
        const packageInfosBeforeSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        expect(packagePublish_1.packagePublish(packageInfosBeforeSync['apkg'], registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(packageInfosBeforeSync['bpkg'], registry.getUrl(), '', '').success).toBeTruthy();
        const newFooInfo = yield createTempPackage('apkg', '2.0.0', 'beta');
        const newBarInfo = yield createTempPackage('bpkg', '3.0.0', 'latest');
        expect(packagePublish_1.packagePublish(newFooInfo, registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(newBarInfo, registry.getUrl(), '', '').success).toBeTruthy();
        yield sync_1.sync({
            all: false,
            branch: 'origin/master',
            command: 'sync',
            message: '',
            path: repo.rootPath,
            publish: false,
            bumpDeps: false,
            push: false,
            registry: registry.getUrl(),
            gitTags: false,
            tag: 'beta',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: false,
            generateChangelog: false,
            dependentChangeType: null,
        });
        const packageInfosAfterSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        expect(packageInfosAfterSync['apkg'].version).toEqual('2.0.0');
        expect(packageInfosAfterSync['bpkg'].version).toEqual('2.2.0');
        expect(packageInfosAfterSync['cpkg'].version).toEqual('3.0.0');
    }));
    it('can perform a successful sync by forcing dist tag version', () => __awaiter(void 0, void 0, void 0, function* () {
        const repo = yield repositoryFactory.cloneRepository();
        yield createRepoPackage(repo, 'epkg', '1.0.0');
        yield createRepoPackage(repo, 'fpkg', '2.2.0');
        yield createRepoPackage(repo, 'gpkg', '3.0.0');
        const packageInfosBeforeSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        const epkg = packageInfosBeforeSync['epkg'];
        const fpkg = packageInfosBeforeSync['fpkg'];
        epkg.combinedOptions.tag = 'latest';
        fpkg.combinedOptions.tag = 'latest';
        expect(packagePublish_1.packagePublish(epkg, registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(fpkg, registry.getUrl(), '', '').success).toBeTruthy();
        const newFooInfo = yield createTempPackage('epkg', '1.0.0-1');
        const newBarInfo = yield createTempPackage('fpkg', '3.0.0');
        newFooInfo.combinedOptions.tag = 'prerelease';
        newBarInfo.combinedOptions.tag = 'latest';
        expect(packagePublish_1.packagePublish(newFooInfo, registry.getUrl(), '', '').success).toBeTruthy();
        expect(packagePublish_1.packagePublish(newBarInfo, registry.getUrl(), '', '').success).toBeTruthy();
        yield sync_1.sync({
            all: false,
            branch: 'origin/master',
            command: 'sync',
            message: '',
            path: repo.rootPath,
            publish: false,
            bumpDeps: false,
            push: false,
            registry: registry.getUrl(),
            gitTags: false,
            tag: 'prerelease',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: false,
            generateChangelog: false,
            forceVersions: true,
            dependentChangeType: null,
        });
        const packageInfosAfterSync = getPackageInfos_1.getPackageInfos(repo.rootPath);
        expect(packageInfosAfterSync['epkg'].version).toEqual('1.0.0-1');
        expect(packageInfosAfterSync['fpkg'].version).toEqual('2.2.0');
        expect(packageInfosAfterSync['gpkg'].version).toEqual('3.0.0');
    }));
});
//# sourceMappingURL=syncE2E.test.js.map