"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const registry_1 = require("../fixtures/registry");
const npm_1 = require("../packageManager/npm");
const writeChangeFiles_1 = require("../changefile/writeChangeFiles");
const workspace_tools_1 = require("workspace-tools");
const publish_1 = require("../commands/publish");
const repository_1 = require("../fixtures/repository");
const monorepo_1 = require("../fixtures/monorepo");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
describe('publish command (e2e)', () => {
    let registry;
    let repositoryFactory;
    beforeAll(() => {
        registry = new registry_1.Registry();
        jest.setTimeout(30000);
    });
    afterAll(() => {
        registry.stop();
    });
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield registry.reset();
    }));
    afterEach(() => __awaiter(void 0, void 0, void 0, function* () {
        if (repositoryFactory) {
            yield repositoryFactory.cleanUp();
            repositoryFactory = undefined;
        }
    }));
    it('can perform a successful npm publish', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new repository_1.RepositoryFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const showResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(showResult.success).toBeTruthy();
        const show = JSON.parse(showResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.1.0');
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        const gitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(gitResults.success).toBeTruthy();
        expect(gitResults.stdout).toBe('foo_v1.1.0');
    }));
    it('can perform a successful npm publish in detached HEAD', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new repository_1.RepositoryFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['checkout', '--detach'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: false,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const showResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(showResult.success).toBeTruthy();
        const show = JSON.parse(showResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.1.0');
    }));
    it('can perform a successful npm publish from a race condition', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new repository_1.RepositoryFactory();
        repositoryFactory.create();
        const repo = repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        // Adds a step that injects a race condition
        let fetchCount = 0;
        workspace_tools_1.addGitObserver((args, output) => {
            if (args[0] === 'fetch') {
                if (fetchCount === 0) {
                    const anotherRepo = repositoryFactory.cloneRepository();
                    // inject a checkin
                    const packageJsonFile = path_1.default.join(anotherRepo.rootPath, 'package.json');
                    const contents = JSON.parse(fs_extra_1.default.readFileSync(packageJsonFile, 'utf-8'));
                    fs_extra_1.default.writeFileSync(packageJsonFile, JSON.stringify(Object.assign(Object.assign({}, contents), { version: '1.0.2' }), null, 2));
                    workspace_tools_1.git(['add', packageJsonFile], { cwd: anotherRepo.rootPath });
                    workspace_tools_1.git(['commit', '-m', 'test'], { cwd: anotherRepo.rootPath });
                    workspace_tools_1.git(['push', 'origin', 'HEAD:master'], { cwd: anotherRepo.rootPath });
                }
                fetchCount++;
            }
        });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const showResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(showResult.success).toBeTruthy();
        const show = JSON.parse(showResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.1.0');
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        const gitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(gitResults.success).toBeTruthy();
        expect(gitResults.stdout).toBe('foo_v1.1.0');
        // this indicates 2 tries
        expect(fetchCount).toBe(2);
    }));
    it('can perform a successful npm publish from a race condition in the dependencies', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new repository_1.RepositoryFactory();
        repositoryFactory.create();
        const repo = repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        // Adds a step that injects a race condition
        let fetchCount = 0;
        workspace_tools_1.addGitObserver((args, output) => {
            if (args[0] === 'fetch') {
                if (fetchCount === 0) {
                    const anotherRepo = repositoryFactory.cloneRepository();
                    // inject a checkin
                    const packageJsonFile = path_1.default.join(anotherRepo.rootPath, 'package.json');
                    const contents = JSON.parse(fs_extra_1.default.readFileSync(packageJsonFile, 'utf-8'));
                    delete contents.dependencies.baz;
                    fs_extra_1.default.writeFileSync(packageJsonFile, JSON.stringify(contents, null, 2));
                    workspace_tools_1.git(['add', packageJsonFile], { cwd: anotherRepo.rootPath });
                    workspace_tools_1.git(['commit', '-m', 'test'], { cwd: anotherRepo.rootPath });
                    workspace_tools_1.git(['push', 'origin', 'HEAD:master'], { cwd: anotherRepo.rootPath });
                }
                fetchCount++;
            }
        });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const showResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(showResult.success).toBeTruthy();
        const show = JSON.parse(showResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.1.0');
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        const gitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(gitResults.success).toBeTruthy();
        expect(gitResults.stdout).toBe('foo_v1.1.0');
        // this indicates 2 tries
        expect(fetchCount).toBe(2);
        const packageJsonFile = path_1.default.join(repo.rootPath, 'package.json');
        const contents = JSON.parse(fs_extra_1.default.readFileSync(packageJsonFile, 'utf-8'));
        expect(contents.dependencies.baz).toBeUndefined();
    }));
    it('can perform a successful npm publish without bump', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new repository_1.RepositoryFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: false,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const showResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(showResult.success).toBeTruthy();
        const show = JSON.parse(showResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.0.0');
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        const gitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(gitResults.success).toBeFalsy();
    }));
    it('should not perform npm publish on out-of-scope package', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new monorepo_1.MonoRepoFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        writeChangeFiles_1.writeChangeFiles({
            bar: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'bar',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            scope: ['!packages/foo'],
            retries: 3,
            bump: true,
            generateChangelog: true,
            dependentChangeType: null,
        });
        const fooNpmResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(fooNpmResult.success).toBeFalsy();
        const fooGitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(fooGitResults.success).toBeFalsy();
        const barNpmResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'bar', '--json']);
        expect(barNpmResult.success).toBeTruthy();
        const show = JSON.parse(barNpmResult.stdout);
        expect(show.name).toEqual('bar');
        expect(show.versions.length).toEqual(1);
        expect(show['dist-tags'].latest).toEqual('1.4.0');
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        const barGitResults = workspace_tools_1.git(['describe', '--abbrev=0', 'bar_v1.4.0'], { cwd: repo.rootPath });
        expect(barGitResults.success).toBeTruthy();
        expect(barGitResults.stdout).toBe('bar_v1.4.0');
    }));
    it('should respect prepublish hooks', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new monorepo_1.MonoRepoFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            hooks: {
                prepublish: (packagePath) => {
                    const packageJsonPath = path_1.default.join(packagePath, 'package.json');
                    const packageJson = fs_extra_1.default.readJSONSync(packageJsonPath);
                    if (packageJson.onPublish) {
                        Object.assign(packageJson, packageJson.onPublish);
                        delete packageJson.onPublish;
                        fs_extra_1.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
                    }
                },
            },
            dependentChangeType: null,
        });
        // Query the information from package.json from the registry to see if it was successfully patched
        const fooNpmResult = npm_1.npm(['--registry', registry.getUrl(), 'show', 'foo', '--json']);
        expect(fooNpmResult.success).toBeTruthy();
        const show = JSON.parse(fooNpmResult.stdout);
        expect(show.name).toEqual('foo');
        expect(show.main).toEqual('lib/index.js');
        expect(show.hasOwnProperty('onPublish')).toBeFalsy();
        workspace_tools_1.git(['checkout', 'master'], { cwd: repo.rootPath });
        workspace_tools_1.git(['pull'], { cwd: repo.rootPath });
        // All git results should still have previous information
        const fooGitResults = workspace_tools_1.git(['describe', '--abbrev=0'], { cwd: repo.rootPath });
        expect(fooGitResults.success).toBeTruthy();
        const fooPackageJson = fs_extra_1.default.readJSONSync(path_1.default.join(repo.rootPath, 'packages/foo/package.json'));
        expect(fooPackageJson.main).toBe('src/index.ts');
        expect(fooPackageJson.onPublish.main).toBe('lib/index.js');
    }));
    it('should respect postpublish hooks', () => __awaiter(void 0, void 0, void 0, function* () {
        repositoryFactory = new monorepo_1.MonoRepoFactory();
        yield repositoryFactory.create();
        const repo = yield repositoryFactory.cloneRepository();
        let notified;
        writeChangeFiles_1.writeChangeFiles({
            foo: {
                type: 'minor',
                comment: 'test',
                email: 'test@test.com',
                packageName: 'foo',
                dependentChangeType: 'patch',
            },
        }, repo.rootPath);
        workspace_tools_1.git(['push', 'origin', 'master'], { cwd: repo.rootPath });
        yield publish_1.publish({
            all: false,
            branch: 'origin/master',
            command: 'publish',
            message: 'apply package updates',
            path: repo.rootPath,
            publish: true,
            bumpDeps: true,
            push: true,
            registry: registry.getUrl(),
            gitTags: true,
            tag: 'latest',
            token: '',
            yes: true,
            new: false,
            access: 'public',
            package: '',
            changehint: 'Run "beachball change" to create a change file',
            type: null,
            fetch: true,
            disallowedChangeTypes: null,
            defaultNpmTag: 'latest',
            retries: 3,
            bump: true,
            generateChangelog: true,
            hooks: {
                postpublish: packagePath => {
                    const packageJsonPath = path_1.default.join(packagePath, 'package.json');
                    const packageJson = fs_extra_1.default.readJSONSync(packageJsonPath);
                    if (packageJson.afterPublish) {
                        notified = packageJson.afterPublish.notify;
                    }
                },
            },
            dependentChangeType: null,
        });
        const fooPackageJson = fs_extra_1.default.readJSONSync(path_1.default.join(repo.rootPath, 'packages/foo/package.json'));
        expect(fooPackageJson.main).toBe('src/index.ts');
        expect(notified).toBeDefined();
        expect(notified).toBe(fooPackageJson.afterPublish.notify);
    }));
});
//# sourceMappingURL=publishE2E.test.js.map