"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const find_up_1 = __importDefault(require("find-up"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const tmp_1 = __importDefault(require("tmp"));
const git_1 = require("../git");
// tmp is supposed to be able to clean up automatically, but this doesn't always work within jest.
// So we attempt to use its built-in cleanup mechanisms, but tests should ideally do their own cleanup too.
tmp_1.default.setGracefulCleanup();
let fixturesRoot;
let tempRoot;
let tempNumber = 0;
/**
 * Create a temp directory containing the given fixture name in a git repo.
 * Be sure to call `cleanupFixtures()` after all tests to clean up temp directories.
 */
function setupFixture(fixtureName) {
    if (!fixturesRoot) {
        fixturesRoot = find_up_1.default.sync("__fixtures__", { cwd: __dirname, type: "directory" });
    }
    const fixturePath = path_1.default.join(fixturesRoot, fixtureName);
    if (!fs_extra_1.default.existsSync(fixturePath)) {
        throw new Error(`Couldn't find fixture "${fixtureName}" under "${fixturesRoot}"`);
    }
    if (!tempRoot) {
        // Create a shared root temp directory for fixture files
        tempRoot = tmp_1.default.dirSync({ unsafeCleanup: true }); // clean up even if files are left
    }
    const cwd = path_1.default.join(tempRoot.name, String(tempNumber++), fixtureName);
    fs_extra_1.default.mkdirpSync(cwd);
    fs_extra_1.default.copySync(fixturePath, cwd);
    git_1.init(cwd, "test@test.email", "test user");
    git_1.stageAndCommit(["."], "test", cwd);
    return cwd;
}
exports.setupFixture = setupFixture;
function cleanupFixtures() {
    if (tempRoot) {
        tempRoot.removeCallback();
        tempRoot = undefined;
    }
}
exports.cleanupFixtures = cleanupFixtures;
