"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const find_up_1 = __importDefault(require("find-up"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lockfile_1 = require("@yarnpkg/lockfile");
const lockfile_file_1 = require("@pnpm/lockfile-file");
function nameAtVersion(name, version) {
    return `${name}@${version}`;
}
exports.nameAtVersion = nameAtVersion;
const memoization = {};
async function parseLockFile(packageRoot) {
    const yarnLockPath = await find_up_1.default(["yarn.lock", "common/config/rush/yarn.lock"], { cwd: packageRoot });
    // First, test out whether this works for yarn
    if (yarnLockPath) {
        if (memoization[yarnLockPath]) {
            return memoization[yarnLockPath];
        }
        const yarnLock = fs_extra_1.default.readFileSync(yarnLockPath).toString();
        const parsed = lockfile_1.parse(yarnLock);
        memoization[yarnLockPath] = parsed;
        return parsed;
    }
    // Second, test out whether this works for pnpm
    let pnpmLockPath = await find_up_1.default(["pnpm-lock.yaml", "common/config/rush/pnpm-lock.yaml"], { cwd: packageRoot });
    if (pnpmLockPath) {
        if (memoization[pnpmLockPath]) {
            return memoization[pnpmLockPath];
        }
        const parsed = await lockfile_file_1.readWantedLockfile(path_1.default.dirname(pnpmLockPath), {
            ignoreIncompatible: true,
        });
        const object = {};
        if (parsed && parsed.packages) {
            for (const [pkgSpec, snapshot] of Object.entries(parsed.packages)) {
                // TODO: handle file:foo.tgz syntax (rush uses this for internal package links)
                const specParts = pkgSpec.split(/\//);
                const name = specParts.length > 3
                    ? `${specParts[1]}/${specParts[2]}`
                    : specParts[1];
                const version = specParts.length > 3 ? specParts[3] : specParts[2];
                object[nameAtVersion(name, version)] = {
                    version,
                    dependencies: snapshot.dependencies,
                };
            }
        }
        memoization[pnpmLockPath] = { object, type: "success" };
        return memoization[pnpmLockPath];
    }
    throw new Error("You do not have either yarn.lock nor pnpm-lock.yaml. Please use one of these package managers");
}
exports.parseLockFile = parseLockFile;
function queryLockFile(name, versionRange, lock) {
    const versionRangeSignature = nameAtVersion(name, versionRange);
    return lock.object[versionRangeSignature];
}
exports.queryLockFile = queryLockFile;
